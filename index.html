<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M.A.I.A: AI Website Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensures full viewport height */ 
            margin: 0;
            background-color: #f0f2f5; /* Soft background */
        }

        /* The main content area that will hold either chat or preview */
        #main-content-area {
            flex-grow: 1; /* Takes all available vertical space */
            width: 100%;
            max-width: 100%; /* Ensure it spans full width on all devices */
            position: relative; /* Crucial for absolute positioning of its children */
            overflow: hidden; /* Hide overflow from children if necessary */
            background-color: #ffffff; /* Default background */
        }
        
        /* Chat and Preview Interfaces: absolute position to fill #main-content-area */
        #chat-interface, #preview-interface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Enable scrolling for content */
            padding: 1.5rem; /* Consistent padding */
            transition: opacity 0.3s ease-in-out; /* Smooth transition on switch */
        }
        #chat-interface {
            background-color: #ffffff;
            /* Initially visible by default, so no 'hidden' class here */
        }
        #preview-interface {
            background-color: #fcfcfc; /* Slightly different background for preview */
            justify-content: center; /* Center preview content if not filling fully */
            align-items: center;
            text-align: center;
            opacity: 0; /* Initially transparent */
            pointer-events: none; /* Disable interaction when hidden */
            z-index: 10; /* Ensure it overlays chat if both are visible during transition (though one will be hidden) */
        }

        /* Chat messages specific */
        .chat-messages {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Space between messages */
            padding-right: 0.5rem; /* Room for scrollbar */
            overflow-y: auto; /* Enable scrolling for chat */
        }
        .chat-message {
            padding: 0.75rem 1rem;
            border-radius: 1rem; /* More rounded bubbles */
            max-width: 75%; /* Slightly smaller bubbles */
            box-shadow: 0 1px 3px rgba(0,0,0,0.08); /* Subtle shadow */
            line-height: 1.4;
        }
        .chat-message.user {
            background-color: #4f46e5; /* Indigo for user */
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 0.3rem; /* Tighter corner for speaking end */
        }
        .chat-message.ai {
            background-color: #e2e8f0; /* Light gray for AI */
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 0.3rem; /* Tighter corner for speaking end */
        }
        #typing-indicator {
            background-color: #f0f4f8; /* Even lighter gray for typing */
            color: #666;
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Input area styling */
        #input-footer {
            background-color: #ffffff;
            border-top: 1px solid #e0e0e0;
            padding: 1rem 1.5rem; /* Padding matches main content */
            display: flex;
            flex-direction: column; /* Stack input and button vertically on small screens */
            gap: 1rem; /* Space between input group and toggle button */
            align-items: center; /* Center horizontally */
        }

        @media (min-width: 768px) { /* Adjust for larger screens */
            #input-footer {
                flex-direction: row; /* Row layout on larger screens */
                justify-content: space-between;
                align-items: center;
            }
        }

        #message-input-group {
            flex-grow: 1;
            display: flex;
            width: 100%; /* Full width within footer on small screens */
        }
        @media (min-width: 768px) {
            #message-input-group {
                max-width: calc(100% - 180px); /* Leave space for toggle button */
            }
        }

        #user-input {
            background-color: #f9fafb; /* Very light input background */
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: #333;
            flex-grow: 1;
            border-right: none; /* No border between input and button */
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        #user-input:focus {
            outline: none;
            border-color: #6366f1; /* Focus color */
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); /* Focus ring */
        }
        #submit-button {
            background-color: #4f46e5; /* Primary button color */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 5px rgba(79, 70, 229, 0.2);
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        #submit-button:hover {
            background-color: #4338ca; /* Darker on hover */
            transform: translateY(-1px); /* Slight lift */
        }
        #submit-button:active {
            transform: translateY(0);
        }
        #message-input-group.disabled-state #submit-button {
            background-color: #a7a7a7; /* Greyed out when disabled */
            box-shadow: none;
        }

        /* Toggle View Button */
        #toggle-view-button {
            background-color: #6366f1; /* Secondary button color */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.2);
            white-space: nowrap; /* Prevent text wrapping */
        }
        #toggle-view-button:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }
        #toggle-view-button:active {
            transform: translateY(0);
        }

        /* Mockup container within preview */
        #preview-interface .mockup-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            max-width: 800px; /* Limit mockup grid width */
            margin: 0 auto; /* Center the grid */
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 1rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        #preview-interface .mockup-item {
            border: 1px solid #c2c9d1;
            border-radius: 0.75rem;
            padding: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            overflow: hidden;
        }
        #preview-interface .mockup-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #preview-interface .mockup-item img {
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            width: 100%;
            height: auto;
            display: block;
        }
        #preview-interface .mockup-item p {
            padding: 0.75rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: #444;
            background-color: #f0f2f5;
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
        }

        /* Iframe styling for final preview */
        #preview-interface iframe {
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 100%; /* Ensure it fits within parent */
            height: 100%; /* Take full height of flex-grow parent */
        }

    </style>
</head>
<body>
    <!-- Main content area that switches between chat and preview -->
    <div id="main-content-area" class="flex-grow">
        <!-- Chat Interface - Initially visible -->
        <div id="chat-interface">
            <div class="chat-messages">
                <p class="chat-message ai">Hello! Describe the website you'd like to build to begin.</p>
            </div>
        </div>
        <!-- Preview Interface - Initially hidden -->
        <div id="preview-interface" class="hidden">
            <p>Preview area. Content not yet available.</p>
        </div>
    </div>

    <!-- Input Footer -->
    <footer id="input-footer" class="flex-shrink-0">
        <button id="toggle-view-button" class="hidden">Show Preview</button>
        <div id="message-input-group">
            <input id="user-input" type="text" placeholder="Start a conversation..." aria-label="Type your message">
            <button id="submit-button" aria-label="Send message">Proceed</button>
        </div>
    </footer>

    <script>
        // --- DOM Element References ---
        const submitButton = document.getElementById('submit-button');
        const userInput = document.getElementById('user-input');
        const messageInputGroup = document.getElementById('message-input-group');
        const mainContentArea = document.getElementById('main-content-area');
        const chatInterface = document.getElementById('chat-interface');
        const chatMessages = chatInterface.querySelector('.chat-messages');
        const previewInterface = document.getElementById('preview-interface');
        const toggleViewButton = document.getElementById('toggle-view-button');

        // --- Workflow State Management ---
        let aiWorkflowPhase = 'initialQuery'; // initialQuery, awaitingMockupSelection, awaitingPlanApproval, codeGenerated
        let initialUserQuery = '';
        let generatedMockupsData = []; // To store base64 data of the 4 mockups
        let selectedMockupData = '';   // To store the chosen mockup's data
        let websitePlan = '';          // To store the output from the planning agent
        let currentView = 'chat';      // 'chat' or 'preview' - tracks which interface is currently visible
        let previewAvailable = false;  // True when mockups or code have been generated

        // --- Helper Functions ---
        /**
         * Switches the active view between chat and preview.
         */
        function switchView() {
            if (currentView === 'chat') {
                if (previewAvailable) {
                    chatInterface.classList.add('hidden');
                    previewInterface.classList.remove('hidden');
                    previewInterface.style.opacity = 1; // Ensure it's fully visible
                    previewInterface.style.pointerEvents = 'auto'; // Re-enable interaction
                    toggleViewButton.textContent = 'Show Chat';
                    currentView = 'preview';
                }
            } else { // currentView === 'preview'
                previewInterface.classList.add('hidden');
                previewInterface.style.opacity = 0; // Fade out
                previewInterface.style.pointerEvents = 'none'; // Disable interaction
                chatInterface.classList.remove('hidden');
                chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom when returning to chat
                toggleViewButton.textContent = 'Show Preview';
                currentView = 'chat';
            }
        }

        /**
         * Adds a message to the chat interface.
         * @param {string|HTMLElement} content - The message content (string or a DOM element).
         * @param {boolean} isUser - True if the message is from the user, false otherwise (M.A.I.A).
         * @param {string} className - Additional Tailwind CSS classes to apply to the message bubble.
         */
        function addMessage(content, isUser = false, className = '') {
            const messageDiv = document.createElement('p');
            messageDiv.classList.add('chat-message'); // Base class for all messages

            if (isUser) {
                messageDiv.classList.add('user');
            } else {
                messageDiv.classList.add('ai');
            }

            // Conditionally add className only if it's not empty, and split it by spaces
            if (className) {
                className.split(' ').forEach(cls => {
                    if (cls) { // Ensure no empty strings from multiple spaces
                        messageDiv.classList.add(cls);
                    }
                });
            }

            if (typeof content === 'string') {
                messageDiv.innerHTML = content; // Use innerHTML to allow for bold tags etc.
            } else {
                messageDiv.appendChild(content); // Append actual DOM element
            }
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to the bottom
        }

        /**
         * Adds a typing indicator message to the chat.
         */
        function addTypingIndicator() {
            const typingIndicator = document.createElement('p');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.classList.add('chat-message', 'ai'); // Apply base message styles
            typingIndicator.textContent = 'M.A.I.A is typing...';
            chatMessages.appendChild(typingIndicator);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        /**
         * Removes the typing indicator from the chat.
         */
        function removeTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        /**
         * Disables the user input field and submit button.
         * @param {string} placeholderText - The placeholder text to display in the input field.
         */
        function disableInput(placeholderText = "Processing...") {
            userInput.disabled = true;
            submitButton.disabled = true;
            userInput.placeholder = placeholderText;
            messageInputGroup.classList.add('disabled-state');
        }

        /**
         * Enables the user input field and submit button.
         */
        function enableInput() {
            userInput.disabled = false;
            submitButton.disabled = false;
            userInput.placeholder = "Start a conversation...";
            submitButton.textContent = "Proceed"; // Reset button text
            messageInputGroup.classList.remove('disabled-state');
            userInput.focus();
        }

        /**
         * Generates a refined prompt for the image generator based on the user's initial query.
         * Uses the gemini-2.0-flash model for this purpose.
         * @param {string} userQuery - The initial query from the user.
         * @returns {Promise<string>} A promise that resolves with the generated image prompt string.
         */
        async function generateImageGenPrompt(userQuery) {
            addTypingIndicator();
            disableInput("Refining prompt for image generation...");
            addMessage("M.A.I.A: Understanding your request to generate a precise image prompt...", false, 'text-gray-600');

            const promptRefinementInstruction = `You are an AI assistant specialized in generating concise and effective prompts for an image generation AI (Imagen 3.0). Your goal is to transform a user's general website description into a specific, high-quality prompt that will produce a direct visual *screenshot* or *webpage view* of a website.

The image should look like a clean, direct screenshot of the website interface itself, without any framing elements.

Focus on the overall layout, color scheme, and aesthetic vibe. Do NOT include any specific text content, navigation items, or detailed features, as these will be handled in later planning and code generation stages.

The output should be ONLY the prompt string, ready for the image generator.

Example User Query: "I want a modern portfolio website for a graphic designer."
Example Output: "A clean screenshot of a minimalist and contemporary website interface for a graphic designer's portfolio, with a spacious layout and a muted color palette (e.g., grays, soft blues, whites). Direct webpage view."

Now, generate a prompt based on the following user query: "${userQuery}"`;

            const payload = {
                contents: [{ role: "user", parts: [{ text: promptRefinementInstruction }] }],
            };
            const apiKey = "AIzaSyCYc0DkE70DDJllm0XYQ2wpKuhl_kwjAHA"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                    
                    const imagePrompt = result.candidates[0].content.parts[0].text.trim();
                    removeTypingIndicator();
                    addMessage(`M.A.I.A: Generated image prompt: "${imagePrompt}"`, false, 'text-gray-600');
                    return imagePrompt;
                } else {
                    removeTypingIndicator();
                    addMessage("M.A.I.A: Failed to generate a refined image prompt. Using original query.", false, 'text-orange-500');
                    console.error("Error: Image prompt generation returned unexpected structure:", result);
                    return userQuery; // Fallback to original query
                }
            } catch (error) {
                removeTypingIndicator();
                addMessage("M.A.I.A: Error refining image prompt. Using original query.", false, 'text-orange-500');
                console.error("Error calling Image Prompt Generation Agent:", error);
                return userQuery; // Fallback to original query
            }
        }


        /**
         * Generates image mockups based on the user's query (or refined prompt) using Imagen API.
         * Displays 4 mockups for the user to select.
         * @param {string} query - The prompt for image generation, directly from the prompt generation AI.
         */
        async function generateImageMockups(query) {
            addTypingIndicator();
            disableInput("Generating 4 design mockups...");
            addMessage("M.A.I.A: Generating four initial design mockups based on your request...", false, 'text-gray-600');
            
            const payload = { 
                instances: { prompt: query }, 
                parameters: { "sampleCount": 4 } // Request 4 images
            };
            const apiKey = "AIzaSyCYc0DkE70DDJllm0XYQ2wpKuhl_kwjAHA"; // Canvas environment will inject API key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                removeTypingIndicator();

                // Check if predictions exist and are not empty
                if (result.predictions && result.predictions.length > 0) {
                    generatedMockupsData = result.predictions.map(p => p.bytesBase64Encoded);
                    
                    const mockupContainer = document.createElement('div');
                    mockupContainer.className = 'mockup-container';

                    generatedMockupsData.forEach((base64, index) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'mockup-item';
                        itemDiv.dataset.mockupIndex = index + 1; // Store index for selection
                        itemDiv.addEventListener('click', (e) => {
                            const selectedIndex = parseInt(e.currentTarget.dataset.mockupIndex);
                            userInput.value = selectedIndex; // Populate input with selection
                            submitButton.click(); // Programmatically click submit
                        });

                        const imgElement = document.createElement('img');
                        imgElement.src = `data:image/png;base64,${base64}`;
                        imgElement.alt = `Generated Website Mockup ${index + 1}`;
                        const label = document.createElement('p');
                        label.textContent = `Mockup ${index + 1}`;
                        itemDiv.appendChild(imgElement);
                        itemDiv.appendChild(label);
                        mockupContainer.appendChild(itemDiv);
                    });

                    // Clear preview and add mockups to the preview interface
                    previewInterface.innerHTML = ''; 
                    previewInterface.appendChild(mockupContainer);

                    addMessage("M.A.I.A: Here are four design concepts. Please tap on your favorite mockup (1-4). If you don't like any, type 'new ones'.", false);
                    
                    aiWorkflowPhase = 'awaitingMockupSelection';
                    enableInput();
                    userInput.placeholder = "Tap a mockup or type 'new ones'";
                    submitButton.textContent = "Select";
                    
                    previewAvailable = true;
                    if (currentView === 'chat') { // Only show button if currently in chat view
                        toggleViewButton.classList.remove('hidden');
                        toggleViewButton.textContent = 'Show Preview';
                    } else { // If already in preview (e.g. from previous generation), just update button
                        toggleViewButton.textContent = 'Show Chat';
                    }
                    switchView(); // Automatically switch to preview to show mockups

                } else {
                    // Handle cases where no predictions are returned
                    addMessage("M.A.I.A: Failed to generate mockups. The AI did not return any design concepts. Please try a different prompt.", false, 'text-red-500');
                    aiWorkflowPhase = 'initialQuery'; 
                    enableInput();
                    // Keep the toggle button hidden if no preview is generated
                    toggleViewButton.classList.add('hidden');
                }

            } catch (error) {
                removeTypingIndicator();
                addMessage("M.A.I.A: Failed to generate mockups. Please try a different prompt.", false, 'text-red-500');
                console.error("Error calling Image Generation API:", error);
                aiWorkflowPhase = 'initialQuery'; 
                enableInput();
                // Keep the toggle button hidden on error
                toggleViewButton.classList.add('hidden');
            }
        }

        /**
         * Generates a detailed website plan using the Gemini-2.0-Flash model.
         * The plan is based on the user's initial query and the selected image mockup (as inspiration).
         * @param {string} userQuery - The initial query from the user.
         * @param {string} imageBase64 - The base64 encoded string of the selected image mockup.
         */
        async function generateWebsitePlan(userQuery, imageBase64) {
            addTypingIndicator();
            disableInput("Planning Agent at work...");
            addMessage("M.A.I.A: Great choice! The Planning Agent is now analyzing your request and the selected design to create a structural plan...", false, 'text-gray-600');

            const planningPrompt = `You are an expert Website Planning Agent. Your task is to analyze the user's initial request and the selected website mockup. Based on these inputs, create a detailed, structured plan for building the website. The mockup is for inspiration to get the "vibe" and "look" the user is seeking, not for exact emulation or recreation. The plan should outline the following in a clear, easy-to-read format: 
1.  **Overall Goal**: A brief summary of the website's purpose.
2.  **Layout & Structure**: Describe the main sections (e.g., Navigation Bar, Hero Section, About Me, Portfolio Grid, Footer). Refer to the mockup for inspiration on the general arrangement and flow.
3.  **Key Components**: List specific elements within each section (e.g., Logo, Nav Links, Heading, Subheading, Call-to-Action Button).
4.  **Color Palette**: Identify the primary, secondary, and accent colors from the image, using them as inspiration for the overall color scheme.
5.  **Typography**: Suggest appropriate font styles (e.g., a sans-serif for headings, a serif for body text), taking inspiration from the visual style of the mockup.

User's initial request: "${userQuery}"`;
            
            const payload = {
                contents: [{
                    parts: [
                        { text: planningPrompt },
                        { inline_data: { mime_type: "image/png", data: imageBase64 } }
                    ]
                }]
            };
            const apiKey = "AIzaSyCYc0DkE70DDJllm0XYQ2wpKuhl_kwjAHA"; // Canvas environment will inject API key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`; 

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                // Add checks for undefined properties
                if (result.candidates && result.candidates.length > 0 && 
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                    
                    websitePlan = result.candidates[0].content.parts[0].text;
                    removeTypingIndicator();
                    addMessage("<strong>Website Plan:</strong><br><pre class='whitespace-pre-wrap font-sans text-sm'>" + websitePlan + "</pre>", false, 'bg-green-50 border border-green-200');
                    addMessage("M.A.I.A: The plan is ready. If you're happy with it, type <b>'Proceed'</b> to build the final website.", false);
                    aiWorkflowPhase = 'awaitingPlanApproval';
                    enableInput();
                    userInput.placeholder = "Type 'Proceed' to approve the plan";
                    submitButton.textContent = "Proceed";
                    
                    // After plan, switch back to chat (as user needs to input "Proceed")
                    currentView = 'preview'; // Temporarily set to preview so switchView correctly goes to chat
                    switchView();
                    previewAvailable = true;
                    toggleViewButton.classList.remove('hidden'); // Ensure button is visible
                    toggleViewButton.textContent = 'Show Preview'; // Set text for when in chat view
                } else {
                    removeTypingIndicator();
                    addMessage("M.A.I.A: The Planning Agent failed to generate a valid plan. The response was unexpected. Please try again.", false, 'text-red-500');
                    console.error("Error: Planning Agent returned unexpected structure:", result);
                    aiWorkflowPhase = 'awaitingMockupSelection'; 
                    enableInput();
                }
            } catch (error) {
                removeTypingIndicator();
                addMessage("M.A.I.A: The Planning Agent failed. Please try again.", false, 'text-red-500');
                console.error("Error calling Planning Agent:", error);
                aiWorkflowPhase = 'awaitingMockupSelection'; // Allow user to try again or select a new mockup
                enableInput();
            }
        }

        /**
         * Generates the final HTML code for the website using the Gemini-2.0-Flash model.
         * The code generation is based on the initial query, selected mockup, and the generated plan.
         * The generated code is then displayed in an iframe in the preview tab.
         * @param {string} userQuery - The initial query from the user.
         * @param {string} imageBase64 - The base64 encoded string of the selected image mockup.
         * @param {string} plan - The detailed website plan generated by the Planning Agent.
         */
        async function generateWebsiteCode(userQuery, imageBase64, plan) {
            addTypingIndicator();
            disableInput("Code Agent is building...");
            addMessage("M.A.I.A: Plan approved! The Code Generation Agent is now writing the final HTML based on all the information. This may take a moment...", false, 'text-gray-600');
            
            const codeGenPrompt = `You are an expert frontend developer. Your task is to generate a single, self-contained HTML file based on the comprehensive inputs provided.
            
Inputs:
1.  **Original User Request**: "${userQuery}"
2.  **The Approved Structural Plan**: 
    ---
    ${plan}
    ---
3.  **The Visual Style Reference**: An image of the desired website is also provided. Use this image as inspiration for the overall layout, color scheme, and aesthetic "vibe" of the generated HTML. Do not attempt to recreate the image pixel-for-pixel, but capture its essence and general look.

Requirements:
-   The output must be ONLY the raw HTML code, starting with \`<!DOCTYPE html>\`.
-   Use Tailwind CSS for ALL styling. Include the necessary Tailwind CDN script tag in the \`<head>\`.
-   Do NOT use inline \`style\` attributes or external CSS files.
-   Make the content relevant to the user's request (e.g., use placeholder text suitable for a chef's blog if that was the request).`;

            const payload = {
                contents: [{
                    parts: [
                        { text: codeGenPrompt },
                        { inline_data: { mime_type: "image/png", data: imageBase64 } }
                    ]
                }]
            };
            const apiKey = "AIzaSyCYc0DkE70DDJllm0XYQ2wpKuhl_kwjAHA"; // Canvas environment will inject API key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                let generatedCode = "";

                if (result.candidates && result.candidates.length > 0 && 
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                    
                    generatedCode = result.candidates[0].content.parts[0].text;
                    // Extract only the HTML code if it's wrapped in markdown code block
                    if (generatedCode.includes('```html')) {
                        generatedCode = generatedCode.split('```html')[1].split('```')[0].trim();
                    }

                    previewInterface.innerHTML = ''; // Clear previous content
                    const iframe = document.createElement('iframe');
                    iframe.style.cssText = 'width: 100%; height: 100%; flex-grow: 1; border: 1px solid #e2e8f0; border-radius: 0.375rem;';
                    iframe.srcdoc = generatedCode; // Load the generated HTML into the iframe
                    previewInterface.appendChild(iframe);
                    
                    removeTypingIndicator();
                    addMessage("M.A.I.A: Success! Your website has been generated. View it now in the preview.", false);
                    aiWorkflowPhase = 'codeGenerated';
                    disableInput("Website generated. Refresh to start a new one."); // User cannot input further
                    
                    previewAvailable = true;
                    if (currentView === 'chat') {
                        toggleViewButton.classList.remove('hidden');
                        toggleViewButton.textContent = 'Show Preview';
                    } else {
                        toggleViewButton.textContent = 'Show Chat';
                    }
                    switchView(); // Automatically switch to preview to show final website

                } else {
                     removeTypingIndicator();
                    addMessage("M.A.I.A: The Code Agent failed to generate valid code. The response was unexpected. Please try again.", false, 'text-red-500');
                    console.error("Error: Code Agent returned unexpected structure:", result);
                    aiWorkflowPhase = 'awaitingPlanApproval'; 
                    enableInput();
                }
            } catch (error) {
                removeTypingIndicator();
                addMessage("M.A.I.A: The Code Agent failed. Please try again.", false, 'text-red-500');
                console.error("Error calling Code Generation Agent:", error);
                aiWorkflowPhase = 'awaitingPlanApproval'; // Allow user to try generating code again
                enableInput();
            }
        }

        // --- Main event listener is now a more complex state machine
        /**
         * Main event listener for the submit button.
         * Controls the workflow based on the current `aiWorkflowPhase`.
         */
        submitButton.addEventListener('click', async function() { 
            const enteredText = userInput.value.trim();
            if (!enteredText) return;

            // Only add user message to chat if currently in chat view
            if (currentView === 'chat') {
                addMessage(enteredText, true);
            }
            userInput.value = '';

            switch(aiWorkflowPhase) {
                case 'initialQuery':
                    initialUserQuery = enteredText;
                    // No more fancy UI animation on first chat; it's always there
                    // Call the new prompt generation step first
                    const imagePrompt = await generateImageGenPrompt(initialUserQuery);
                    if (imagePrompt) {
                        generateImageMockups(imagePrompt);
                    } else {
                        // If prompt generation fails, fallback to original query for mockups
                        generateImageMockups(initialUserQuery);
                    }
                    break;

                case 'awaitingMockupSelection':
                    if (enteredText.toLowerCase().includes('new')) {
                        // If user wants new mockups, generate new prompt and then new mockups
                        const imagePromptForNew = await generateImageGenPrompt(initialUserQuery);
                        if (imagePromptForNew) {
                            generateImageMockups(imagePromptForNew);
                        } else {
                            generateImageMockups(initialUserQuery); // Fallback
                        }
                    } else {
                        const selection = parseInt(enteredText);
                        if (!isNaN(selection) && selection >= 1 && selection <= 4) {
                            selectedMockupData = generatedMockupsData[selection - 1];
                            generateWebsitePlan(initialUserQuery, selectedMockupData);
                        } else {
                            addMessage("M.A.I.A: Please enter a valid number between 1 and 4 or 'new ones'.", false, 'text-red-500');
                            // Ensure we're in chat view to show this message
                            if (currentView !== 'chat') {
                                switchView(); 
                            }
                        }
                    }
                    break;

                case 'awaitingPlanApproval':
                    if (enteredText.toLowerCase().includes('proceed')) {
                        generateWebsiteCode(initialUserQuery, selectedMockupData, websitePlan);
                    } else {
                        addMessage("M.A.I.A: Understood as feedback. In a future version, I'll use this to refine the plan. For now, please type 'Proceed' to continue or refresh to start over.", false);
                        // Ensure we're in chat view to show this message
                        if (currentView !== 'chat') {
                            switchView();
                        }
                    }
                    break;
                case 'codeGenerated':
                    // If code is already generated, user can't input further for this session
                    addMessage("M.A.I.A: The website has already been generated. Refresh the page if you'd like to build a new one.", false, 'text-gray-500');
                    // Ensure we're in chat view to show this message
                    if (currentView !== 'chat') {
                        switchView();
                    }
                    break;
            }
        });

        /**
         * Allows submitting the message by pressing Enter key.
         */
        userInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                submitButton.click();
            }
        });

        // Toggle view button event listener
        toggleViewButton.addEventListener('click', switchView);

        // Initial setup: ensure only chat is visible and preview button is hidden
        chatInterface.classList.remove('hidden');
        previewInterface.classList.add('hidden');
        toggleViewButton.classList.add('hidden');
    </script>
</body>
</html>

